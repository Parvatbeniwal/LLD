## Java Thread Pool Limits

### Executors.newFixedThreadPool(100_000_000)
Compiles, but **not feasible** in practice.

---

### Why?
- Each thread = **native OS thread**
- Needs stack memory (~1 MB default) + kernel resources
- 100M threads â†’ would require **~100 TB RAM**, impossible on real systems

---

### Results
- Fails with `OutOfMemoryError: unable to create new native thread`
- Or system slowdown/crash due to context switching

---

### Best Practices
- **CPU-bound tasks** â†’ use `Runtime.getRuntime().availableProcessors()`
- **IO-bound tasks** â†’ can use larger pools, but typically in the **100s/1000s**, not millions
- For huge concurrency â†’ use:
    - **Virtual Threads (Java 21+)**
    - `CompletableFuture`
    - Reactive frameworks

---

### ðŸ‘‰ Takeaway
No hard Java API limit, but **OS + hardware enforce practical limits**.  
âœ… Use thread pools wisely based on workload type.


### Rule of thumb:

- Use execute() [Takes Runnable] for simple, no-result, fire-and-forget tasks.
- Use submit()  [Takes Runnable or Callable.] if you need results, error handling, or task tracking.

# Java Concurrency: execute() vs submit(), Runnable vs Callable

####  1. `submit(...)` (ExecutorService)
- **Defined in:** `ExecutorService` interface
- **Accepts:** `Runnable` or `Callable`
- **Return type:** `Future<?>`
- **Exceptions:** Captured inside the `Future` and retrieved via `future.get()`
- **Best for:** Tasks where you need a **result** or **error handling**

### Example with Runnable
```java
ExecutorService executor = Executors.newFixedThreadPool(2);

Future<?> future = executor.submit(() -> {
    System.out.println("Runnable via submit()");
});
```

### Example with Callable
```
ExecutorService executor = Executors.newFixedThreadPool(2);

Future<Integer> future = executor.submit(() -> {
    return 42; // Callable returns a value
});

System.out.println("Result = " + future.get());
```

